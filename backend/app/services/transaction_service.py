import httpx
import logging
from sqlalchemy.orm import Session
from sqlalchemy.sql import text
from datetime import datetime

logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

class TransactionService:
    def __init__(self, db: Session):
        self.db = db
        self.chatbot_url = "http://chatbot_service:8002"

    def serialize_datetime(self, obj):
        """Convert datetime objects to ISO 8601 strings."""
        if isinstance(obj, datetime):
            return obj.isoformat()
        return obj

    def normalize_sql(self, sql_query: str) -> str:
        """Normalize multi-line SQL into a single-line string."""
        return " ".join(line.strip() for line in sql_query.splitlines() if line.strip())

    async def generate_sql_and_execute(self, user_query: str):
        """Generate SQL query via chatbot and execute it, returning a combined response."""
        try:
            # Step 1: Call chatbot service to generate SQL query
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.chatbot_url}/generate_sql",
                    json={"query": user_query},
                    timeout=10.0
                )
                response.raise_for_status()
                sql_query = response.json().get("sql_query")
                if not sql_query or not isinstance(sql_query, str):
                    return {"error": "No valid SQL query generated by chatbot"}
                normalized_sql = self.normalize_sql(sql_query)
                logger.debug(f"Executing SQL: {normalized_sql}")

            # Step 2: Execute the SQL query
            result = self.get_transactions(normalized_sql)
            if "error" in result:
                return result

            # Step 3: Prepare the result
            db_data = [
                {k: self.serialize_datetime(v) for k, v in row.items()}
                for row in result["db_data"]
            ]

            # Step 4: Send query and db_data to chatbot for human-readable response
            chat_query_payload = {"query": user_query, "db_data": db_data}
            async with httpx.AsyncClient() as client:
                chat_response = await client.post(
                    f"{self.chatbot_url}/chat",
                    json=chat_query_payload,
                    timeout=10.0
                )
                chat_response.raise_for_status()
                chatbot_message = chat_response.json().get("response", "No response from chatbot")

            return {
                "query": user_query,
                "db_data": db_data,
                "chat_response": chatbot_message
            }
        except httpx.RequestError as e:
            logger.error(f"Chatbot service communication failed: {str(e)}")
            return {"error": f"Failed to communicate with chatbot service: {str(e)}"}
        except Exception as e:
            logger.error(f"Unexpected error in query processing: {str(e)}")
            return {"error": f"Unexpected error: {str(e)}"}

    def get_transactions(self, sql_query: str):
        """Execute the SQL query and return the result."""
        try:
            result = self.db.execute(text(sql_query))
            rows = [dict(row) for row in result.mappings()]
            return {"db_data": rows}
        except Exception as e:
            logger.error(f"Error executing SQL query: {str(e)}")
            return {"error": f"Error executing query: {str(e)}"}
        